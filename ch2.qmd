# データ整形および操作: tidyr, dplyrパッケージの基礎 {#data-manipulation}

前章において、Rでさまざまな処理が適用しやすいtidyデータについて述べたが、本章の前半で具体的に手持ちのデータをtidyな形式へ変換する方法を学ぶ。後半は、tidyに整理した後に実行するであろう、データの操作を紹介する。これらの方法はデータの種類に問わず、あらゆるデータで共通な、データの選択や抽出、加工、結合という処理を含んでおり、多くの場面で活用の機会がある。

## データ自由自在

データのあり方が多種多様であることは前章で述べた通りである。そこで、雑多なデータを規則的な形式に整形し、コンピュータによる処理を適用しやすくしたものをtidyデータと言う。ここではtidyデータの条件として定義されている形式へとのデータ整形に有効な関数を備えたRパッケージとして**tidyr**を取り上げる。

```{r}
library(tidyr)
```

### 横長データと縦長データ

同一の対象について反復して記録を行ったデータを反復測定データ、経時観測データと呼ぶ。反復測定データの例として、ある植物個体の高さについて2015年4月から2017年3月まで毎月1回の記録を行ったデータを示そう。

```{r}
# readrを使ったテキストファイルからのデータ読み込み方法は3章で解説する
df_wide <- 
  # 読み込み対象のファイルが置かれているパスをfile引数に指定して実行
  readr::read_csv(file = "data/plants.csv",
                  col_types = readr::cols(
                    .default = readr::col_double(),
                    sp = readr::col_character()
))
```

```{r, echo = FALSE, purl = FALSE, results = "asis"}
df_wide %>% knitr::kable(format = "latex")
```

この植物データに記録された項目は"高さ"のみである。このデータは、対象が定まっているために記録の時期や回数を列として扱い、横方向に長くなる傾向がある。このデータは対象の経年変化を捉えやすいが、記録頻度の高いデータでは、対象全体について把握するのが困難となる。

一方でこのデータは次のように、変数として扱われている調査時期を変数として各項目として調査時期の値を、それに対応させる形で高さの変数とその計測値を記録した3変数のデータとして表現することも可能である。

このデータは調査の対象と回数が増えるほど縦に長くなる特徴がある。しかし、同時に複数の調査項目がある時には変数を追加し、同じファイルあるいはシートで管理できる。

1つの変数の値を複数の変数に分けて記録する横長データに対し、縦長データは項目と値の関係を1つの列とその値として完結させている。生物サイズの例では、もともと変数名に使われていた調査時期をperiodという列として定義し、サイズについてはperiodとひもづく形で記述するようになっている。これは各変数は独立した1つの列、1行につき1つの観測値というtidyデータの原則に従っている。

#### 横長と縦長の相互変換

それでは**tidyr**パッケージを使ってこのデータ変形を行ってみよう。植物データセットは現在、**df_wide**というオブジェクト名で保存されている。まずは今一度**df_wide**の列名を確認しよう。

```{r}
names(df_wide)
```

一列目は"sp"という列で、個体を識別するための固有な値となっている。これは`$`演算子を使って列の項目をベクトル化させることで簡単に確認できる。

```{r}
df_wide$sp
```

**df_wide**の残りの列は数値で表され、調査が行われた時期が西暦月の値（2015年4月の場合は201504）が使われている。各列に含まれる値が高さの観測値である。これらの列は本質的に共通である変数（高さ）を扱っているので、調査時期と高さの観測値の組み合わせからなる列にすることができる。この処理を実行するには`gather()`を利用する。

`gather()`は第一引数に与えたデータを対象として、キーバリューと呼ばれるkeyとvalueの2つの対となるデータ形式に整形する関数である。keyはvalueに記録される項目、valueにはkeyが扱う値が記録される。`gather()`ではkeyとvalueはそれぞれ第二、第三引数ので指定する。*key*引数は元のデータで変数として扱われていた名前が入る列で、*value*引数で指定した変数には、*key*と対になる値が入る。また`gather()`を実行する時は、全ての変数名が*value*で指定した列に格納される候補となるので、変数として残す列は`-`を使って`gather()`の対象から除外する必要がある。

植物データに対して、調査時期をkey、高さの観測値をvalueとしたキーバリュー形式を適用すると次のようになる。なお個体識別の列である"sp"列は変数として残しておくことに注意である。キーバリューでは、キーとする項目の数が増えるほど縦長のデータになる特徴がある。

```{r}
# 横長から縦長データの変換
df_long <-
  df_wide %>%
  # key... 変数を元に作成される変数
  # value... keyで対象となる変数の値を保存する変数
  # 対象から除外する列は - を使って取り除く
  gather(key = period, value = height, -sp)

head(df_long)
```

```{r, eval = TRUE, purl = FALSE}
# sp列を除外しない場合、
# spの値を含めてキーバリュー形式に変形する
df_wide %>%
  gather(period, height) %>%
  head()
```

次に縦長になったデータを横長に戻す処理を実行しよう。`spread()`は`gather()`と対をなす関数で、*key*引数に指定された値を列名、*value*引数で指定された変数の値をその値として格納する。

```{r}
# 縦長から横長への再変換
df_wide2 <-
  df_long %>%
  spread(key = period, value = height)

head(df_wide2, 3)
```

### 複数列への分割

tidyデータへの整形の例として次に、1つの列で分割可能な値を扱っている場合の処理として`separate()`および`extract()`を使った例を取り上げる。

植物データの"sp"列の値を見ると、「a_1」、「a_2」という規則性のある文字列になっている。これはa種の1番目の個体、a種の2番目の個体、...という具合に個体識別のために記録されているものである。一方で種aだけのデータや各種の1番目の個体について対象にした処理を加える際にはこの列は分割しておいた方が良い。このようなデータは複数列に分割するのがtidyデータとして適切である。ここでは引き続き、縦長になった**df_long**を対象として、"sp"列の値を分割してみよう。

```{r}
# 同一の変数内に複数の要素をもつデータを2つの変数に分割する
df_long %>%
  separate(
    # 分割対象の変数
    col = sp,
    # 区切り文字
    sep = "_",
    # 値を保存する列を指定する
    into = c("species", "number"),
    #
    extra = "warn",
    # removeは、col引数の値を残すかを定義する
    remove = TRUE) %>%
  head(3)
```

関数`separate`は引数*col*に分割対象とする変数名を指定し、*into*引数に分割したデータを格納する変数名を与えて実行することで、一つの列に含まれる値を複数の列へと分割する。分割の基準は*sep*引数で指定する。*sep*には既定値として正規表現の`[^[:alnum:]]+`によるパターンが与えられているが、任意の区切り文字やパターンを指定可能である\footnote{正規表現については4章を参照}。

`separate()`の仕様では、はじめに*sep*の値による値の分割が実施され、次にその値を*into*列に代入するという流れになる。そのため、*into*での列数と分割後の要素数が一致しない場合、何らかの警告が表示される。また引数*extra*に既定の"warn"を指定していると、指定した列に含まれない、つまり以降の要素についてはデータから除去される。引数*extra*には"warn"と"drop"、"merge"の3つの値が指定できる。"warn"は既定値であり、要素と列の不一致に対する警告を表示する。"drop"では列に入りきらない値については警告も表示せずに切り落とす。"merge"を設定しておくと、切り落としは実行されず、列に入りきる状態で*col*の値が分割される。代入先の変数の数が不足する場合や過剰な変数の指定についても同様に警告が表示される。この場合、要素が足りないものには欠損値が与えられる。

変数分割の処理として次に`extract()`の例を示す。`extract()`は、1つの列にまとまっている変数を引数*regex*に指定した正規表現などの基準によって複数の列に分割する。この関数の利用例として、行の中に複数の値が記録されている場合や、特定の基準によって変数を分割するべき状況が考えられる。

```{r}
df_plants_sep <-
  df_long %>%
  extract(col = sp,
          # 分割後の変数名を与える
          into = c("species", "number"),
          # 分割する文字列を指定する
          regex = "([[:alnum:]]+)_([[:alnum:]]+)",
          # 元の列は取り除く
          remove = TRUE)

head(df_plants_sep, 3)
```

`separate()`や`extract()`により分割した変数を一つの変数に結合するには`unite()`を利用する。`unite()`では*col*引数に結合した変数を格納する変数名を与え、残りの引数に結合対象の列を指定する。既定値では全ての変数が結合対象となる。

`extract()`を使って変数を分割した**df_plants_sep**の列を再び一つの変数として結合した例を次に示す。species、numberの列の値を*sep*で指定した文字列"\_"で結合し、新たにsp列として扱う、という処理である。

```{r}
# unite()の引数sepで変数間の値をつなげる文字列を指定する
df_plants_sep %>%
  unite(
    # 新しく作成する変数の名前を指定
    col = sp,
    # 区切り文字として結合時に利用する文字列
    sep = "_",
    # 対象のデータフレームに含まれる変数名が結合に用いられる
    species, number) %>%
  head(3)
```

`unite()`には*remove*引数が用意されており、既定では*TRUE*が与えられている。これは結合に指定された元の変数を取り除くオプションである。

### 複数行への分割

一行に分割可能な値が記録されており、それを列ではなく行方向へ展開する場合に便利な関数として`separate_rows()`を紹介する。

例えば次のような、idごとに複数のタグが記録され、それがカンマ区切りで一つの変数(tag)に記録されたデータがあるとする。各タグにはそれと対応してスコアが与えられているが、その値もまた別の列(score)にカンマ区切りで記録されている。これをデータフレームの変数名はそのままに、タグとスコアを一対の関係として一行ごとに記録したデータへと整形しよう。

```{r}
df_wide_col <- 
  tibble(
  id    = 1:3,
  tag   = c("apple,banana,melon", "grape,orange", "peer,mango,pine apple"),
  score = c("0.7,0.5,0.4", "0.6,0.2", "0.7,0.4,0.3")
)

# tag, scoreは対応関係にある
df_wide_col
```

`separate_rows()`では、引数にデータフレームの変数名を与えて実行する。分割の対象となる区切り文字を*sep*で指定するが、この例では区切り文字は","となる。

```{r}
df_wide_col %>% 
  separate_rows(tag, score, sep = ",") %>% 
  head()
```

関数を実行すると、タグの項目とスコアが一行ずつ記録されたデータになったことが確認できるが、scoreが文字列のデータとなっていることに注意しよう。`separate_rows()`の処理は、元の変数のデータ型を引き継ぐため、分割後の変数も文字列のままである。そのため分割後のデータ型を見直すためのオプションとして、`separate_rows()`では引数*convert*が用意される。*convert*引数で*TRUE*を指定した際、変換可能な変数がある場合、以下の例の通り、データ型の自動変換が行われる。

```{r}
df_wide_col %>% 
  separate_rows(tag, score, sep = ",", convert = TRUE) %>% 
  head(3)
```

### 入れ子データ

文字列や因子型の変数は、グループとして共通の処理を施したり、グループごとの値を参照することがある。標準関数では`split()`によるデータの分割が可能であるが、これは対象がデータフレームであっても返り値はリストである。そこで、データフレームの構造を維持したままデータをグループに分割するには`nest()`が有効となる。

`nest()`の実行例として、sp、period、heightの3列からなる次のデータを、調査個体ごとのデータとして扱えるようにする処理を示す。

```{r}
head(df_long)

df_nest <- 
  df_long %>% 
  nest(period, height)

df_nest
```

`nest()`はデータフレームを第一引数にとり、関数内で指定されたデータフレーム中の変数を別のデータフレームとして処理し、入れ子のように新たな変数として格納する。このような、大きさ(データフレームの場合は行数)が異なるデータを、データフレームの一変数として扱うデータ構造を本書では入れ子データ nested data frameと呼ぶ。

`nest()`により、入れ子としてまとめられるデータは変数dataに格納される（これは引数*key*で指定した名前に変更することができる）。入れ子のデータを確認するには、変数dataを参照する。

```{r}
# spがa_1の値かならるデータを格納する
df_nest$data[[1]]
```

変数の指定方法は、既定では全ての変数が対象となっている。すなわち対象のデータフレーム中の変数名が与えられない場合はデータフレーム自体を入れ子にする。変数の指定方法は、入れ子にする変数名を直接与える他、列番号、コロン(":")を使った連続した変数の選択、マイナス記号("-")による除外などが可能である。

```{r, eval = FALSE, echo = TRUE}
# これらの処理は上記の処理と等しい

# - で入れ子に含めない変数を与える
df_long %>% 
  nest(-sp)

# 列番号による指定
df_long %>% 
  nest(2, 3)

df_long %>% 
  nest(period:height)
```

```{r}
# 変数名を指定しない場合は全ての変数を入れ子に含める
df_long %>% 
  nest()
```

![入れ子データのイメージ](images/fig-ch7-nested-data-frame.png)

入れ子を解除するには、`unnest()`を使う。これにより入れ子データとする前のデータ構造が復元される。

```{r, eval = FALSE, echo = TRUE}
df_nest %>% 
  unnest()
```

`unnest()`にはいくつかのオプションが備わっている。例えば`unnest()`を実行した時に用いられる変数名は、入れ子に含まれていた元の変数名であるが、`.sep`で、`nest()`を実行した時の入れ子の変数名(`.data`引数で調整。既定値はdata)に続けて任意の文字列を含ませるようになる。

```{r, eval = FALSE, echo = TRUE}
# 入れ子データを展開した時の変数名を "data_(元の変数名)" とする
df_nest %>% 
  unnest(.sep = "_")
```

また`unnest()`は、データ型が等しい、リストの要素を一行ずつ展開する機能も備えている。例えば次のようにlist列に、行ごとに長さの異なるベクトルがリストとして格納されているデータに対して、1行に要素の1つの値を含んだデータへ変換する。

```{r}
# 長さの異なる要素をもつリストの列を含んだデータフレームを用意
(df <- 
  tibble(
    id   = 1:3,
    list = list("a" = 1,
                "b" = 2:3,
                "c" = 4:6)))

```

```{r}
# .id引数は、展開されたデータを識別するのに有効である
df %>% 
  unnest(.id = "list_id")
```

## 柔軟なデータ操作

tidyverseにはデータ操作のためのパッケージとして**dplyr**が整備されている。**dplyr**パッケージは"A Grammar of Data Manipulation"を掲げ、データ操作を文法として捉え、複雑になりがちなデータ操作を簡潔に記述することを可能としている。**dplyr**の機能を見るため、以下のコードを実行し、パッケージとデータセットを利用可能なようにしておこう。データは前章で扱った**trees**データと**mtcars**データである。

```{r load_package, message = FALSE}
# dplyrパッケージの読み込み
library(dplyr)
data("trees")
data("mtcars")
```

### データ操作における5つの工程

データに行う基本操作は、**選択**、**抽出**、**並び替え**、**集計**、**加工**の5工程に分けられる。データ分析の前処理として、これらの操作を組み合わせデータを加工したあとで、可視化やモデリング、分析関数を実施することになるだろう。

**dplyr**パッケージではこれらのデータ操作のための処理を個別の関数として提供する。加工と選択を実行する関数はそれぞれ`mutate()`および`transmute()`、`select()`であり、抽出は`filter()`、`summarise()`による集計、並び替えは`arrange()`で実行される。

選択 select: 必要な変数を参照・抽出する、不要な変数を削除する

抽出 filter: 特定の条件に一致する値を取り出す

並び替え arrange: 変数内の項目の順序を変更する

集計 summarise: データ全体あるいはグループ別の代表値・統計量等の算出

加工 mutate, transmute: 値の単位・尺度などを変更する、新たな列を追加する

![データ操作をdplyrの関数で実施する例](images/fig-ch2-dplyr-data-manupulation.png)

<!-- 1枚の図ではなく、以下の個々の関数の説明時にデータがどうなるかという感じで図示するのが良さそう -->

これらのデータ操作関数の特徴は、基本的にはtidyverseの原則に従い、第一引数に対象のデータ、上記の5つの関数は全てデータフレームをとり、関数内部で処理内容を記述するという形式をとる。**dplyr**のフレームワークでは、関数名はデータに適用する「動詞」、その内容を「文法」として表現する。

### データを抽出する: filter

データ抽出とは、データからあるまとまりを取り出すことである。部分集合を抽出すると言い変えても良い。`filter()`は**比較・論理演算子**を用いた条件指定を行い、**条件に該当するデータ (TRUEとなる値)を返す**関数である。関数の第一引数には対象のデータをとり、以降に条件式を記述して実行する。

条件式は、左辺に対象の変数を指定して不等号を挟んで右辺に比較する値を与える、という記述となる。**trees**の"Volume"列の値が52以上のデータを抽出するコードは次のようになる。

```{r, dplyr_filter}
# filter()では比較演算子を用いたデータ抽出を実行する
trees %>% filter(Volume >= 52.0)
```

このコードの「文法」を読み解いてみよう。データ抽出を実行する`filter()`に、**trees**をパイプ演算子で対象に与えている。続く第二引数に、具体的な条件を指定しているが、ここで注目すべきは"Volume"列の参照に`$`演算子を必要とせず、変数名を直接指定することである。**dplyr**を使ったデータ操作では、主な対象がデータ自身とその変数になるため、変数を参照する`$`は省略可能になっている。

複数の条件を指定して抽出をする場合、カンマ (`,`)あるいは縦線 (`|`)により条件となる処理を区切る。ここでカンマは「かつ and」であり、縦線は「または or」である。次の実行例は「Heightが65より小さい、またはVolumeが52以上の行を抽出」する。

```{r, dplyr_filter2}
trees %>% filter(Height < 65 | Volume >= 52.0)
```

<!-- Table: Rにおける比較・論理演算子-->

| 演算子 | 効果                               |
|--------|------------------------------------|
| `>`    | 左辺が右辺より大きい               |
| `>=`   | 左辺が右辺より大きいか等しい       |
| `<`    | 左辺が右辺より小さい               |
| `<=`   | 左辺が右辺より小さいか等しい       |
| `==`   | 左辺と左辺が一致する               |
| `!=`   | 左辺と左辺不一致                   |
| `|`    | 論理和 (2つの条件式のいずれかが真) |
| `&`    | 論理積 (2つの条件式が共に真)       |

一つの変数に複数の条件を与える場合、`|`と同等の機能をもつ`%in%`演算子を利用することもできる。`%in%`演算子は`match()`関数の機能を演算子として提供するもので、左辺ベクトルから右辺のベクトルの値を抽出する。

```{r dplyr_filter3, eval = FALSE, echo = TRUE}
# 2つの処理結果は等しい
trees %>% filter(Height == 70 | Height == 81)
# %in%演算子を使い、左辺に含まれる右辺のベクトルの値を抽出する
mtcars %>% filter(cyl %in% c(6, 8))
```

また数値を対象にとり、範囲指定による抽出が`between()`を用いることで可能である。この関数は第一引数に対象の数値ベクトル、第二、第三引数で下限と上限を指定し、範囲に含まれるかを論理値で返す。この関数を`filter()`に用いた例を以下に示す。

```{r dplyr_filter4_between, results = "hide"}
# disp列の値が200から300までの値を抽出する
mtcars %>% filter(between(disp, 200, 300))
```

#### 欠損値を含む変数に対するfilter()の働き

欠損値を含んだ変数について`filter()`を実行した結果を確かめておこう。`filter()`では記述した条件に従う値を取り出すという処理が適用されるため、下記のコードを実行すると欠損値を含んだ行は除外される。

```{r}
d <- tibble(var = c(1, 2, NA, 4, 5))

d %>% filter(var >= 2)
```

変数varが2以上の値の抽出に欠損値を含んだ行を加えるにはどうすれば良いだろうか。これには縦線による「または」の条件に欠損値である値を指定すると良い。

```{r}
d %>% filter(var >= 2 | is.na(var))
```

#### 位置を利用した抽出

特定の変数の値が大きいあるいは小さいものから何行か分の抽出を行いたい、という時には`top_n()`や`nth()`などの関数が役立つ。

`top_n()`は対象をデータフレームとし、引数で行数や基準となる変数を指定する(初期値では第一番目の変数が基準となる)。

```{r}
d <- tibble(var = 1:5)

# var変数が大きな値から2行抽出する
d %>% top_n(n = 2L, wt = var)
# -演算子をつけて降順での抽出を行う
d %>% top_n(-2L, var)
```

一方、`nth()`や`first()`、`last()`はベクトルを対象にとり、それぞれ、任意の位置の値、先頭、末尾の値を抽出する。そのため`filter()`と組み合わせて利用することも可能である。

```{r}
first(d$var)
nth(d$var, 2)
```

```{r}
d %>% filter(var == first(var))
d %>% filter(var == last(var))
d %>% filter(var == nth(var, 2))
```

#### 重複を除いた抽出

データから重複した行を取り除いたユニークなデータへ加工するには関数`distinct()`を用いる。引数に重複のある変数を指定することで、重複を除いた値を返す。一方で変数名を指定した実行では対象外の変数は初期値では削除されてしまうので、ユニークにする処理を行いつつ他の変数を残す場合は*.keep_all*で*TRUE*を指定する必要がある。またこの時、ユニークに扱う変数以外の値は、重複のある行の第一行目の値が選択される。

```{r}
d <- tibble(
  var = c(1, 2, 1, 3, 4),
  var2 = c("A", "B", "A", "A", "D"),
  var3 = c(1.0, 1.0, 1.0, 2.0, 2.3)
)

# データ全体から重複する行を除く
d %>% distinct()
# 引数に指定した変数の重複を解消する
d %>% distinct(var2)
# .keep_allを指定することで
# ユニークな値として扱いつつ他の変数も残す
d %>% distinct(var2, var3, .keep_all = TRUE)
```

また、ベクトルに含まれるユニークな値の数を数える`n_distinct()`もある。この関数は`length(unique(x))`のラッパとして機能するが幾分か処理が高速であり、欠損値をカウントに含めないための引数*na.rm*が用意されている。

```{r}
# 欠損を含んだベクトルを生成
# 3および欠損値 NAが重複
x <- c(NA, 2, 3, 3, NA, 5)
x %>% n_distinct() # NAを含めたユニークな要素の和
x %>% n_distinct(na.rm = TRUE) # 欠損を含めないユニークな要素数
```

#### 選択した行を抽出する

データの抽出方法として、`filter()`のような条件指定による抽出とは別に、`slice()`を利用した位置を指定したデータ抽出がある。これはRで標準的に利用可能な`head()`や`tail()`のようにデータの特定の行を抽出する関数であるが、抽出対象の位置が指定可能な点で異なっている。

```{r}
# 3行目のデータを抽出
trees %>% slice(3L)
# 抽出対象の行数を指定する
trees %>% slice(c(1, 3, 6))
```

#### データの一部を無作為に抽出: sample_n / sample_frac

データからランダムに一部を取り出す時に`sample_n()`および`sample_frac()`が役立つ。これらは引数*size*で指定した条件でいずれも無作為にデータフレームの特定行を抽出する関数であるが、その違いは`sample_n()`は具体的に行数を、`sample_frac()`はデータ全体の行数から抽出するデータの行数の割合を指定するということになる。なお無作為抽出の際に復元抽出を認める*replace*オプションを用意している(既定値では*FALSE*)。

```{r}
# mtcarsデータセットの行数を確認
mtcars %>% nrow()

# 無作為抽出により5行分のデータを抽出
mtcars %>% sample_n(5)

# 復元抽出による無作為抽出
# Toyota Corolla の行が複数回抽出されている点に注意
set.seed(1234)
mtcars %>% sample_n(4, replace = TRUE)

# sample_frac()ではデータセット全体の行数に対する割合を指定
mtcars %>% sample_frac(0.1)
```

### データフレームからの変数選択: select

`select()`は**データフレームから特定の列(変数)を選択する**のに用いられる。選択対象は関数内部で指定された変数になる。対象の変数の列が並ぶ時は`:`を使って表記を省略できる。また対象の変数の前に記号`-`をつけることで選択から除外することもできる。

```{r dplyr_select}
# 変数名を与え、2列を選択する
trees %>%
  select(Height, Volume) %>%
  dim()
# 列番号による変数の選択
trees %>%
  select(c(1, 3)) %>%
  colnames()
# 除外する列名は - で指定する
# mtcarsデータセットのdispからwtまでの列を削除する
mtcars %>%
  select(-(disp:wt), 3) %>%
  head()

# 選択した列の順に変数名が並び替えられる
trees %>%
  select(Volume, Height) %>%
  colnames()
```

#### 変数名の変更: rename

関数`select`では関数内部で`変更後の変数名 = 変更前の変数名`と指定すると選択時に列名の変更ができる。ただし`select()`は、変数を選択する関数であり、選択しなかった変数はデータフレームから除外される。そのため変数名の変更には関数`rename`を用いるか、あるいは`everything()`を使い、全ての変数を選択すると良い。

```{r dplyr_rename}
# 変更後 = 変更前、の形式で変数名を記述することで変数名の変更が行われる
# select()では選択した変数名以外は取り除かれる
trees %>%
  select(height = Height) %>%
  colnames()

# rename()では他の変数に影響を与えずに変数名の変更を行う
trees %>%
  rename(height = Height) %>%
  colnames()

# everything()により他の変数名を残す
# ただし変数の並びが変更されることに注意
trees %>%
  select(height = Height, everything()) %>%
  colnames()
```

#### 変数選択の補助関数

`select_helpers`関数群を利用すると効率的な変数選択が可能になる。これらの関数は、例えば先ほど紹介した「全ての変数を選択する」`everything()`をはじめとして、「XXXで始まる変数」、「XXXとマッチする」というようなパターンマッチや条件指定による選択を実行する。

```{r, include = FALSE}
set.seed(71)
```

```{r}
d <- tibble(
  x_col = 7,
  y_col = c("あ", "い", "う"),
  var_1 = letters[1:3],
  var_2 = 9:7,
  var_3 = c(0.1, NA, 0.4),
  var_z = rnorm(3)
)

# データの変数名を確認
d %>% colnames()
```

<!-- 図あるいは表にする? -->

```{r}
# 'var'で始まる変数を選択する
d %>%
  select(starts_with("var")) %>%
  colnames()

# 'col'で終わる変数を選択
d %>%
  select(ends_with("col")) %>%
  colnames()

# 'co'を含んだ変数を選択
d %>%
  select(contains("co")) %>%
  colnames()

# 正規表現を用いたマッチングによって変数を選択する
d %>%
  select(matches(".ar_[0-9]")) %>%
  colnames()

# 任意の文字列と数値の組み合わせからなる変数を選択
d %>%
  select(num_range("var_", 1:3)) %>%
  colnames()

# 任意の変数集合の中から該当する列を選択
d %>%
  select(one_of(c("var_1", "x_col"))) %>%
  colnames()

# すべての変数を選択
d %>%
  select(y_col, var_z, everything()) %>%
  colnames()
```

`select_helpers`関数群は、`select()`以外の関数、**tidyr**を始めたとしたtidyverseに含まれるパッケージでも利用可能である。また**tidyselect**というパッケージでの開発が進んでおり、将来的にはこちらのパッケージに移植される可能性がある。

### データの並び替え: arrange

データの並び替えは、単純に見た目を良くするためや、集計や加工のために順番を変更する、という理由で行われる。この処理は関数`arrange`により実行する。例えば**trees**データセットでは、Girth列の大きさによってデータが並べられているが、他の変数を基準として順序を入れ替えるという処理を行う時、次のようにする。

```{r}
# treesではGirthの大きさでデータが並ぶ
trees %>% head()
# Height列を基準とした昇順並び替えを行う
trees %>%
  arrange(Height) %>%
  head()
```

`arrange()`はデータを任意の変数を基準に並び替える。この時の並びは昇順となるが、降順指定するには`desc()`を併用する。なお基準とする変数の値が数値型である場合は`-`をつけて降順の指定が可能である\footnote{文字列や日付・時間型のデータでは-演算子の指定はエラーになる}。

```{r}
# 降順に並び替えるにはdesc()や-演算子を用いる
trees %>%
  arrange(desc(Girth)) %>%
  head()
# 数値からなる変数では - で降順指定が可能
trees %>%
  arrange(-Height, -Volume) %>%
  head()
```

### 変数に対する処理: mutate / transmute

データフレームの既存の変数に処理を加えたり、新たな列を追加するには`mutate()`および`transmute()`を利用する。これらの関数では、引数内で算術演算や任意の関数を指定し、データの変数をベクトルとして引数に渡すことが可能である。形式としては、`mutate(データ, 変更後の変数 = 処理内容)`という具合になる。次の例は「**trees**に、各行のGirth列に2.54を乗した値をgirth_cmという列を追加する」という処理である。

```{r dplyr_mutate}
trees %>%
  mutate(girth_cm = Girth * 2.54) %>%
  head(3)
```

`mutate()`では、引数で指定した変数名を追加するが、対象のデータに存在する場合、変数の値を上書きする。

```{r}
trees %>%
  mutate(Height       = as.character(Height),
         Volume_round = round(Volume, digits = 0)) %>%
  head(3)
```

`mutate()`と似た機能をもつ関数として`transmute()`がある。その違いは`mutate()`では変更を加えなかった列も残るのに対し、`transmute()`では引数内部で指定した処理の結果からなるデータフレームを返す点にある。

```{r dplyr_transmute}
# transmute()では実行結果のみからなるデータフレームを返す
trees %>%
  transmute(girth_cm = Girth * 2.54) %>%
  head(3)
```

#### ベクトルを対象とした値の操作

**dplyr**では、ベクトルを対象にしたデータ操作の関数が備わっており、中にはベクトル内の欠損を処理する関数もある。いずれの関数も`mutate()`内外で利用できる。これらの関数はそれぞれ表XXに示すような差異がある。

| 関数          | 特徴                                                                                     |
|---------------|------------------------------------------------------------------------------------------|
| `case_when()` | ベクトルの各要素に対する挙動を指定。指定しない場合には欠損値として扱われる               |
| `recode()`    | ベクトル内の特定の値だけを変更する。変換後の型に注意                                     |
| `if_else()`   | `ifelse()`の拡張。条件式とその結果に対する処理を定義する。欠損値に対する挙動も指定できる |
| `na_if()`     | 特定の値を欠損値へと変換する                                                             |
| `coalesce()`  | 欠損値を特定の値へと変換する                                                             |

関数`if_else`は条件式および、条件式について真・偽であった時の挙動をそれぞれ引数の値として指定して実行する。**trees**のHeight列の値をベクトルとして参照し、各要素が80より大きければ"large"、小さければ"small"を返す例を次に示す。

```{r}
if_else(condition = trees$Height > 80,
        true = "large",
        false = "small")
```

なお`if_else()`では変換に用いる値のデータ型は統一されている必要がある。特に欠損値として処理させる場合、`NA_integer`のようにデータ型についても指定しなければならない点に注意である。

```{r}
# 返り値を欠損値とする場合は
# 真・偽の結果でデータ型を揃える必要がある
x <- c(trees$Height, NA)
```

```{r, eval = FALSE, echo = TRUE, purl = FALSE}
# 整数と実数を区別するため、データ型の不一致によるエラーとなる
if_else(condition = x > 80, 1L, 0)
# Error: `false` must be type integer, not double
```

```{r}
# いずれの返り血も整数型であるので処理は実行される
if_else(condition = x > 80, 1L, 0L)
```

```{r, eval = FALSE, echo = TRUE, purl = FALSE}
# 真であるときの返り値が整数値なので
# 偽であるときの返り値も整数型の欠損値にする
if_else(condition = x > 80, 1L, NA)
# Error: `false` must be type integer, not logical
```

```{r}
if_else(condition = x > 80, 1L, NA_integer_)
```

引数*missing*は欠損値への処理を指定するために利用できる。

```{r}
if_else(condition = x > 80, 1L, 0L, missing = -99L)
```

`if_else()`では、関数の中で指定できる条件は一つなので、より複数の条件を設定するには入れ子としてさらに`if_else()`を記述することが可能である。ただしこのような場合には次の`case_when()`や`recode()`のように複数の条件が指定可能な関数を利用するのが適切である。

`case_when()`は複数の条件分岐をベクトルに適用するのに用いられる。通常の関数とは引数の指定方法が異なっており、関数内部で条件式と、TRUEとなる場合の変更後の値をチルダ記号（\~）で繋いでformulaとして記述する(「対象の値 == 条件式 \~ 変換後の値」)。条件文はカンマによって区切られるが、宣言の順に値の評価が実行される。また対象のベクトルが、記述したいずれかの条件に一致しない場合には欠損値として扱わるという点については注意が必要である。

```{r}
# treesデータセットのGirthの値に応じて指定した文字列を返す
case_when(
  trees$Girth <= 12 ~ "small",
  trees$Girth <= 13 ~ "medium",
  trees$Girth > 13 ~ "large"
)
```

ベクトルの特定の値を変更したい時には`recode()`も利用できる。この関数も引数内で「対象の値 = 変換後の値」を記述する形式となるように、対象となる値を直接記述するのが`case_when()`との違いである。また、変更後の値が指定されていない要素には元の値が採用されるが、引数`.default`に与えた値を利用することもできる。

```{r}
# mtcarsデータセットのcylの値を変更する
recode(mtcars$cyl, `4` = "四", `6` = "六", `8` = "八")
# 変更後の値を指定しない時の挙動 (.default)と、欠損値の変更を.missingにより指定する
recode(c(mtcars$cyl, NA),
       `4` = "四",
       `8` = "八",
       .default = "その他",
       .missing = "なし")
```

```{r, eval = FALSE, echo = TRUE, purl = FALSE}
# 文字列ベクトルに数値を混ぜることはできない
recode(mtcars$cyl, `4` = "四", `6` = "六",  `8` = 8.0)
# Error: Vector 3 must be type character, not double
```

欠損値を処理する関数`na_if()`はベクトル中の欠損値を対象に、*y*引数で指定された特定の値への変換する。`coalesce()`は対象と同じ長さのベクトルを与えることで、欠損値を同じ要素の位置の値で置換する。また、長さが異なるベクトルとして1つの値が与えられた時は、その値が繰り返し使われる。

```{r}
x <- c(1, "", 3, 4)
# ベクトル中の "" を欠損値へ変換
x %>% na_if(y = "")
```

```{r}
x <- c(1, 2, NA, NA, 5)
x %>% coalesce(2)

# 欠損値が含まれる3, 4番目の要素を
# 3, 4へと置換
coalesce(x,
         c(NA, NA, 3, 4, 5))
```

#### 値を前後にずらす: lead / lag

植物データのように行ごとに調査時期と数値のキーペアからなる反復測定データでは、1つ前の期間との差分を求めたり、2つの期間の合計値を求める、などの処理を実施することがある。この処理を実行するには、対象のベクトルの要素を前後にずらして参照する機能をもつ`lead()`および`lag()`を利用する。

次の例は5つの要素をもつベクトル**x**に`lead()`を適用した物である。`lead()`、`lag()`は引数*n*で対象ベクトルの基準となる位置を前後に調整する。ベクトルを参照した時、元の長さ以上の位置にある要素には*NA*が与えられるが、これは*default*引数により任意の値に変更可能である。

<!-- `lead()`や`lag()`は、引数*n*で指定した数だけベクトルを前後にずらし、同じ長さのベクトルを返す処理をする。値の再利用は行われないので、先頭あるいは末尾の値が欠損となることがある。これには引数*default*により任意の値が指定可能である。 -->

```{r}
x <- 1:5

# n の既定値には1が与えられている
x %>% lead()
# 3つ後ろの要素を参照
x %>% lead(3)
# defaultによりNAの値を変更
x %>% lead(3, default = 0)
```

この関数を用いて植物データの各個体の高さ成長が調査時期でどれだけ増えたかを確認しよう。ここでは簡潔な結果を示すために一個体分のデータを用いることにする。

<!-- group_by()の説明が後に入る -->

```{r}
# 植物データ (data/plants.csv)を
# tidyrを用いて縦長にしたデータを利用する

# a_1個体のみを抽出し (filter)、
# periodの並びにする (arrange)
d <-
  df_long %>%
  filter(sp == "a_1") %>%
  arrange(period)

d %>% head()


d$height[2] - d$height[1]
```

ここで2015年4月と次の調査時期である2015年5月の値を見ると、1増えていることがわかる。これを`lag()`で算出しよう。

```{r}
d %>%
  mutate(growth = height - lag(height))
```

#### 順位や割合、累積和を求める: ranking / cumall

ベクトル内の要素の順位や割合を求めるための関数群が`ranking`として提供されている。これを用いて、次のデータフレームの変数*var*の値へ順位に関する関数を適用する例を紹介する。

```{r}
d <- tibble(
  var = c(1:5, 3, NA)
)
mutate(d,
       # 行の順番に番号を与える
       row_number = row_number(),
       # 指定の変数の昇順での順位を与える。
       # 同位値がある場合、同位の数が順位に影響する
       min_rank   = min_rank(var),
       # 同位値の数とは関係なく、連続した順位が与えられる
       dense_rank = dense_rank(var),
       # 順位を0から1の範囲で示す
       percent_rank = percent_rank(var),
       # 順位を積み上げ、全体での割合を示す
       cume_dist = cume_dist(var),
       # データを引数nで指定した値で分割した時のグループ
       ntile = ntile(var, n = 2))
```

*NA*の扱いについては、関数により処理が異なる点に注意である。なおこれらの関数内においても、降順並び替えのための`desc()`や`-`演算子が利用可能である。

<!-- 表 ranking関数 -->

| 関数             | 処理内容                                                                 |
|------------------|--------------------------------------------------------------------------|
| `row_number()`   | 行番号                                                                   |
| `min_rank()`     | 順位(同位値には同じ順位を与える。同位値の数を含めて次の順位が考慮される) |
| `dense_rank()`   | 順位(同位値には同じ順位を与え、以降の順には連続した順位が割り振られる)   |
| `percent_rank()` | 順位のパーセント(0から1の範囲)                                           |
| `cume_dist()`    | 順位の積み上げ値に対する割合(累積比率)                                   |
| `ntile()`        | 指定した群数に分割                                                       |

### 集計値を求める: summarise

`summarise()`は、データ全体あるいはグループに要約統計量を算出するのに役立つ\footnote{dplyrパッケージにはsummarize()という関数もある。ただし、これはイギリス英語とアメリカ英語での単語表記の違いのために用意されたもので機能は変わらない。本書ではsummariseを用いる}。

**trees**の3つの変数に対し、平均 `mean()`、最大値 `max()`、標準偏差 `sd()`を求める処理は以下のようになる。

```{r dplyr_summarise, warning = FALSE}
# 各変数の要約統計量を求める
trees %>% summarise(
  mean_girth = mean(Girth),
  max_height = max(Height),
  sd_volume  = sd(Volume))
```

データに共通の項目、すなわちグループがある場合、グループごとの集計値を求めるには`summarise()`と`group_by()`を組み合わせて利用する。`group_by()`は引数に与えた変数をグループとして扱い、以降の処理をグループ単位で適用する。返り値はデータフレームであるがgrouped_dfというクラスが与えられている。

```{r}
# mtcarsデータセットをcylの値ごとにグループ化する
grp_mtcars <-
  mtcars %>%
  group_by(cyl)

class(grp_mtcars)
```

例えば、**mtcars**の車種のシリンダ (気筒)数ごとの1ガロンあたりの平均走行距離を求めるには次のようなコードを実行する。グループに含まれる値は水準として扱われ、ここでの水準はcylに含まれる4、6、8の3水準である。

```{r dplyr_group_summarise}
# summarise()の処理は水準ごとに出力される
grp_mtcars %>%
  summarise(mean_mpg = mean(mpg))
```

一つの変数を元にグループ化を実行した場合、`summarise()`や`mutate()`関数を適用した後はグループ化が解除されるが、複数の変数からグループを作成した場合、グループの解除は`ungroup()`を使い明示的に実行する必要がある。

```{r dplyr_ungroup}
# 複数の変数でグループを作る
# cylのグループ化は継続する
mtcars %>%
  group_by(cyl, gear) %>%
  summarise(mean_mpg = mean(mpg))

# ungroup()でグループを解除する
mtcars %>%
  group_by(cyl, gear) %>%
  summarise(mean_mpg = mean(mpg)) %>%
  ungroup()
```

#### グループのカウント

要素数を数える関数として`n()`が提供されている。これをグループ化したデータフレームに実行すると、各グループの数を求めるのに便利である。次の処理は、cyl列でグループ化した**matcars**の各cylの値がどれだけ含まれるかを数えた物である。

```{r}
grp_mtcars %>%
  summarise(n = n())
```

また、単にグループの数を求めるという処理の場合には上記の記述を簡略化させた`tally()`や`count()`を用いると良い。`tally()`と`count()`、前者ではあらかじめグループ化されたデータを渡す(`summarise(n = n())`のラッパー関数として動作する)が、後者では引数でグループ化する変数を指定する点が異なる。2つの関数には引数*sort*があり、*TRUE*を指定することで降順並び替えを実行する。

```{r}
# tallyではgroup_by()によりグループ化をあらかじめ実行しておく
mtcars %>%
  group_by(cyl, gear) %>%
  tally()

# count()では引数に含めた変数をグループ化してカウントを実施する
mtcars %>%
  count(cyl, gear)

mtcars %>%
  count(cyl, gear, sort = TRUE)
```

なお、`summarise()`を含め、グループ化したデータのカウントを求める関数では、返り値がデータの集約結果となっているが、`add_tally()`または`add_count()`を使うことで、データフレームの他の変数に影響を及ぼさずにカウント値を算出し、列として追加することができる。

```{r, echo = TRUE}
mtcars %>%
  group_by(cyl) %>%
  add_tally() %>%
  colnames()

# sortの並び替えがデータフレームに対して有効になる
mtcars %>%
  add_count(cyl, sort = TRUE) %>%
  head()
```

グループに関する補助関数として、水準数や水準ごとの件数を出力する関数が用意されている。

```{r dplyr_group_functions}
# グループとなっている変数を確認する
groups(grp_mtcars)
# グループの水準数を数える
n_groups(grp_mtcars)
# グループの水準に含まれる件数を出力
group_size(grp_mtcars)
```

#### グループに対するsummarise以外のデータ操作

<!-- ref) https://github.com/tidyverse/dplyr/blob/master/vignettes/dplyr.Rmd#grouped-operations -->

グループ化されたデータフレームに対する処理は`summarise()`以外でも適用できる。引き続き、**mtcars**のcylについてグループ化したデータを対象に、グループ化されたデータフレームが対象となることで挙動の変化する関数の例を見ていこう。

まず`slice()`でデータの任意の行のデータを抽出する際、グループ化されたデータが対象の場合、グループの各要素の位置からデータを返却する。cylは3つの要素をもつ変数なので、次の処理を実行すると、各グループの要素の値について出力を得る。

```{r}
# グループ化されていないため、
# データ全体から1行を返す
mtcars %>% slice(1L)

# 各グループのデータの先頭から1行抽出。
grp_mtcars %>% slice(1L)
```

```{r}
# グループの要素から各1行返す
grp_mtcars %>% slice(n())

# 各グループからサイズ数のデータを無作為に抽出
grp_mtcars %>% sample_n(2)
```

各グループの最大値あるいは最小値を求めるという処理は、次のように`arrange()`と組み合わせることで実現可能になる。

```{r}
# wtが小さい順に各グループから2行ずつ抽出
grp_mtcars %>%
  arrange(wt) %>%
  slice(1:2L)
```

同様に`sample_n()`や`distinct()`などのデータ抽出に関する関数もグループ化の影響を受ける。

```{r}
mtcars %>% distinct(carb, .keep_all = TRUE) %>%
  nrow()
# 各グループのcarbの値がユニークに処理される
grp_mtcars %>% distinct(carb, .keep_all = TRUE) %>%
  nrow()
```

ベクトルの値を前後にずらす`lead-lag`もグループ化されたデータが対象の際に挙動が変化する。これを利用して、1個体分の高さ成長量を求めた処理を植物データ全体に適用可能になる。

```{r}
df_long %>%
  arrange(sp, period) %>%
  group_by(sp) %>%
  mutate(growth = height - lag(height)) %>%
  ungroup()
```

### 複数列へのデータ操作関数の適用: \_at / \_if / \_all

**dplyr**を使ったデータ操作の関数群では、例えば「共通の接頭語をもつ変数」「文字列である変数」「すべての変数」というような複数の列を同時に処理するための効率的な方法が提供されている。`*_at()`、`*_if()`、`*_all()`である。これらの複数列への処理が可能な関数の原形は、データ操作の基本として本章で取り上げてきた`mutate()`、`transmute()`、`select()`、`filter()`、`summarise()`、`group_by()`、`arrange()`がある。

例えば全ての変数の平均値を`mean()`を使って求めるという処理を`summarise()`関数を使うと次のような記述となるが、`summarise()`の処理を全変数に適用する`summarise_all()`を使うことで簡略化できる。

```{r}
# 各変数の平均値を求める
trees %>%
  summarise(mean_girth = mean(Girth),
            max_height = mean(Height),
            sd_volume  = mean(Volume))
```

```{r}
# summarise_allではデータフレームの全列に関数を適用する
trees %>%
  summarise_all(.funs = mean)
```

```{r, eval = FALSE, echo = TRUE, purl = FALSE}
# 文字列で指定しても良い
trees %>%
  summarise_all(.funs = "mean")

# 関数名を.funsに指定するとエラーになる
trees %>%
  summarise_all(.funs = mean())
# Error in mean.default() : argument "x" is missing, with no default
```

`*_all()`では関数内の引数として、対象のデータに含まれる全ての列に適用する関数名を文字列で指定し、その関数に適用する引数を記述する\footnote{こうした関数を入力にもつ関数を高階関数という。高階関数にはapply()などが該当する。}。すなわち、先の例で各列に適用した関数は`mean()`であったが`mean()`の引数*trim*を有効にするには次のようにする必要がある。

```{r}
# mean()を全ての列に適用するが、
# meanは文字として定義する
trees %>%
  summarise_all(mean, trim = 2)
```

一方で`funs()`を使うことで関数呼び出しのリストを生成することも可能である。この場合、表現式はラムダ式で記述する。

```{r}
# 次の3つの実行結果は全て等しい
trees %>%
  summarise_all(funs(mean(x = ., trim = 2)))
trees %>%
  summarise_all(function(x) {
  mean(x, trim = 2)
})
trees %>%
  summarise_all(funs(mean), trim = 2)
```

いずれの実行結果も各列の変数名を保持しているが、変数名は`funs(変数名 = 適用する関数名)`の形式で調整できる。

```{r}
# 処理後の列名を変更する
trees %>%
  summarise_all(funs(heikin = mean), trim = 2)
```

`*_all()`は、データフレームがもつすべての変数に対し任意の関数を適用するが、変数のデータ型が異なる場合には意図しない出力結果となることがあるので注意が必要である。例えば、先の例では`mean()`をすべての変数に実行したが、文字列型の変数が含まれている場合には欠損値や警告が出力される。このような時には、より柔軟に関数の適用範囲を指定する`*_if()`や`*_at()`を利用すると良い。

`*_if()`は、関数を適用する変数の条件を指定し、その条件に合うものに任意の関数を処理できるようになっている。また`*_at()`は、適用する変数を明示的あるいは補助関数 (変数選択の補助関数を参考)を`vars()`と組み合わせて指定すると良い。

次の例は`select_at()`、`select_if()`を利用して条件に従う変数を選択するものである。1番目は`vars()`を用いて任意の変数名をベクトルとして与え、一致する変数名の列を選択する、という処理になる。2番目の処理は、`vars()`内部で変数選択の補助関数の一種`end_with()`により条件指定を実行している。最後は関数を定義しているが、ここで引数*x*には各変数がベクトルで与えられる。この例では変数のベクトルの合計値が1000以下となる変数を選択するようにしている。ここで注意なのは、対象のデータに数値以外のデータ型の変数が含まれる場合、この処理はエラーになることである。

```{r}
# 選択する変数名を直接指定する
mtcars %>%
  select_at(vars(c("mpg", "cyl", "gear"))) %>%
  names()

# end_with()を使い、pで終わる変数を選択する
mtcars %>%
  select_at(vars(ends_with("p"))) %>%
  names()

# 各列の合計値が1000以下となる変数を選択
trees %>%
  select_if(function(x) sum(x) < 1000) %>%
  names()
```

`summarise_all()`などの関数は、適用する関数の形式（`*_all()`、`_at()`、`_if()`）に応じて、第二引数以降で指定する引数が異なっている。特定の変数を対象とする`*_at`では*.vars*、条件に従う変数を対象にする`*_if`では*.predicate*である。これらはいずれも変数の適用範囲を指定するのに用いられる。そして処理する関数を与える。データ操作の「文法」としては、対象のデータを指定し、その変数の適用範囲を決めたのちに処理する内容を述べる、という具合になる。

```{r}
mtcars %>%
  select_at(vars("mpg", "vs", "am")) %>%
  # vsからamまでを論理値に変換
  mutate_at(vars(vs:am), as.logical) %>%
  head(10)
```

### データの結合

これまで**dplyr**のデータ操作関数の振る舞いについて紹介してきたが、次は2つのデータを結合する処理について見ていこう。データフレームの結合には、`bind_rows()`と`bind_cols()`を用いる方法と、`join`関数群を使う方法とがある。

#### 行・列方向による結合: bind_rows / bind_cols

まず`bind_rows()`、`bind_cols()`だが、この関数は結合するデータの方向性、すなわち行を増やすのか、列を追加するのか、により使い分ける。`bind_rows()`では結合対象のデータの変数名が共通である場合にデータを追加する。共通でない変数名が含まれる場合、それらの列をもたない行については欠損値が与えられる。一方`bind_cols()`は列の結合を実施する関数であり、与えるデータの行数が一致していなければいけない。

**trees**を使って結合の例を示そう。まず**trees**を10行ごとに分割したオブジェクトを作成し、これを`bind_rows()`で結合する。

```{r}
trees_x <- trees[1:10, ]
trees_y <- trees[11:20, ]
trees_z <- trees[21:nrow(trees), ]

bind_rows(trees_x, trees_y) %>%
  dim()
```

`bind_rows()`や`bind_cols()`では、引数に与えたデータを対象に結合の処理を行うが、これらのデータ数に制約はない。つまり複数のデータを一度に結合する処理も可能なのである。

```{r}
bind_rows(trees_x, trees_y, trees_z) %>%
  dim()
```

次に`bind_cols()`の例であるが、結合の方向が異なるだけで`bind_rows()`と差異はない。**trees**の列ごとに結合を行おう。

```{r}
bind_cols(trees[1], trees[2], trees[3]) %>% dim()
```

#### リレーショナルデータの結合: \_join

<!-- 図は配置を含めて再検討 -->

```{r, eval = FALSE, echo = FALSE, purl = FALSE}
 library(gridExtra)
 library(grid)
 library(gtable)
 library(ggplot2)

 padding <- unit(1, "line")
 title_a <- textGrob("A", gp = gpar(fontsize = 22))
 title_b <- textGrob("B", gp = gpar(fontsize = 22))
 gg_null <- ggplot() + xlab("") + ylab("") +
   theme(line = element_blank(),
         text = element_blank(),
         title = element_blank(),
         panel.background  = element_rect(fill = "white", colour = NA))
 p_plus <- gg_null + ggplot2::annotate("text",
                              x = 1, y = 1,
                              label = "+",
                              size = 22)

 p_equal <- gg_null + ggplot2::annotate("text",
                               x = 1, y = 1,
                               label = "=",
                               size = 22)
```

**dplyr**パッケージの`*_join`関数群を使ったデータフレームの結合は、2つのデータのいずれかに含まれる値を結合したり、共通する項目を除外したりと応用範囲の広い結合関数である。基本は引数*x*、*y*に共通の変数をもった対象のデータフレームを指定し、*by*引数で変数名を記述する、という形式になる。

`*_join`関数群の例を見ていくために用意した2つのデータを用意しよう。**df1**は変数:x"と"y"をもつ。また**df2**は変数"x"、"z"をもっている。どちらも3行2列のデータフレームであり、共通する変数は"x"である。

```{r}
# 模擬のデータフレームを生成する
(df1 <- tibble(x = c("A", "B", "C"),
                   y = 1:3))

(df2 <- tibble(x = c("A", "B", "D"),
                   z = c(TRUE, FALSE, TRUE)))
```

<!-- ##### 外部結合・内部結合 -->

`*_join`関数群には2種類の結合形式があるが、一つの結合形式は、`left_join()`、`inner_join()`など、別テーブルと共通する変数を照合し、一致する行に該当する別テーブルの**変数を追加する**結合の方法である。

```{r}
left_join(x = df1, y = df2, by = "x")
```

```{r fig-ch8-left-join, eval = FALSE, echo = FALSE, fig.height = 6, purl = FALSE}
left_join(df.x, df.y, by = "x1") %>%
  tableGrob(rows = NULL) -> df.res

join_image('left_join(by = "x1")', df.res)
```

![左外部結合 left_join](images/fig-ch8-left-join-1.png)

この例では`left_join()`で変数xを*by*に指定している。2つのデータのx変数で共通な値は"A"と"B"である。この共通の値が含まれる**df2**の変数を**df1**に結合するのが`left_join()`の働きとなる。

結合を行う際、2つのデータフレームを紐付ける一つ以上の変数が必要であることが`*_join()`の働きを理解するのに重要である。この役割は引数*by*により指定する。また*by*引数に指定する変数のデータ型は2つのデータで共通でなければならないという制約がある(変数名が同じであっても文字列型と数値型の変数では失敗する)。

**dplyr**ではデータフレームに共通する変数名を自動的に検出し、それを結合に利用する。そのため*by*引数の指定は必須ではない。しかし後でコードを見返したときのため、どの変数をキーとしたかをコードとして記述しておくことが好ましい。

```{r}
# byの指定をしなくても
# 自動的に結合が行われる
df1 %>% left_join(df2)
```

結合する変数名がデータフレーム間で異なる場合には、引数*by*の値を`c(col_a = COL_A)`のように互いの変数名を紐付ける指定をする。先ほど`left_join()`を用いた結合結果を示した**df1**の変数xを`rename()`を使って変更し、その処理を見てみよう。

```{r, eval = FALSE, echo = TRUE, purl = FALSE}
# 共通する変数名が存在しないためエラーになる
df1 %>%
  rename(X = x) %>%
  left_join(df_y)
# Error: `by` required, because the data sources have no common variables
```

```{r}
df1 %>% rename(X = x) %>%
  left_join(df2, by = c("X" = "x"))
```

`*_join`関数群で扱う対象データのうち、引数*x*に与えられるデータを特にマスタと呼ぶ。`left_join()`はマスタに指定したデータに変更を加えるが、マスタに含まれる情報が失われることはない。次に、`*_join`の複数の種類を扱うが、`*_join`関数群の中で利用頻度の高い関数となるだろう。

`left_join()`と同様の働きをもつ`right_join()`があるが、これは引数*y*のデータをマスタとして扱う関数である。そのため次の結果は`df1 %>% left_join(df2)`と同じデータを返すが、注意すべきなのは変数の並びが**df2**に含まれる変数が先に与えられている点である。

```{r}
df2 %>% right_join(df1, by = "x")
```

```{r fig-ch8-right-join, eval = FALSE, echo = FALSE, fig.height = 6, purl = FALSE}
right_join(df.x, df.y, by = "x1") %>%
  tableGrob(rows = NULL) -> df.res

join_image('right_join(by = "x1")', df.res)
```

![右外部結合 right_join](images/fig-ch8-right-join-1.png)

```{r}
df1 %>% inner_join(df2, by = "x")

df1 %>% full_join(df2, by = "x")
```

`inner_join()`は引数*by*で指定された変数の値をもつ行について結合を実施する。`full_join()`は2つのデータに含まれる全ての変数を結合する。

```{r fig-ch8-inner-join, eval = FALSE, echo = FALSE, fig.height = 6, purl = FALSE}
inner_join(df.x, df.y, by = "x1") %>%
   tableGrob(rows = NULL) -> df.res

join_image('inner_join(by = "x1")', df.res)
```

![内部結合 inner_join](images/fig-ch8-inner-join-1.png)

```{r fig-ch8-full-join, eval = FALSE, echo = FALSE, fig.height = 6, purl = FALSE}
full_join(df.x, df.y, by = "x1") %>%
  tableGrob(rows = NULL) -> df.res

join_image('full_join(by = "x1")', df.res)
```

![完全外部結合 full_join](images/fig-ch8-full-join-1.png)

`left_join()`、`right_join()`、`full_join()`のような結合形式は外部結合として知られる。外部結合で一致しない行に追加される変数の値には欠損値が与えられる。一方、`inner_join()`は内部結合と呼ばれる。

`left_join()`等の結合を利用する際、値の重複がある場合には注意が必要である。次の例は変数xを共通してもつ2つのデータの結合であるが、**df2**の変数xには"A"の値が複数出現しており、それぞれが異なるzの値をもっている。この状態だと`x = "A", z = TRUE`、`x = "A", z = FALSE`の2パターンである。このように結合する値がユニークに扱えない時、結合は一致する観測値のすべての組み合わせを返す。この機能は複数変数の組み合わせからなるデータを生成するのに役立つだろう。

```{r}
df1 <- tibble(x = c("A", "B", "C"),
                  y = 1:3)
df2 <- tibble(x = c("A", "B", "D", "A"),
                  z = c(TRUE, FALSE, TRUE, FALSE))

df1 %>% left_join(df2, by = "x")
df1 %>% inner_join(df2, by = "x")
```

<!-- 制限付き結合 -->

`*_join()`群のもう一つの結合形式は、これまで見てきた`left_join()`などの関数が変数を追加する結合であったのに対して変数には影響することはない。マスタとするデータの変数は保持されるが、行について影響する結合となる。このような結合は、結合結果の不一致を確認するのに役立つだろう。

`semi_join()`は2つのデータに含まれる、引数*by*で指定した変数で共通する行を抽出する。`anti_join()`はマスタにのみ含まれる行を抽出する。

```{r}
df1 %>% semi_join(df2, by = "x")
df1 %>% anti_join(df2, by = "x")
```

```{r fig-ch8-semi-join, eval = FALSE, echo = FALSE, fig.height = 6, purl = FALSE}
semi_join(df.x, df.y, by = "x1") %>%
  tableGrob(rows = NULL) -> df.res

join_image('semi_join(by = "x1")', df.res)
```

![準結合 semi_join](images/fig-ch8-semi-join-1.png)

```{r fig-ch8-anti-join, eval = FALSE, echo = FALSE, fig.height = 6, purl = FALSE}
anti_join(df.x, df.y, by = "x1") %>%
  tableGrob(rows = NULL) -> df.res

join_image('anti_join(by = "x1")', df.res)
```

![逆結合 anti_join](images/fig-ch8-anti-join-1.png)

## まとめ

-   多様なデータの表現形式と、コンピュータ処理に適したtidyデータへの相互変換の方法を学んだ。**tidyr**パッケージを使うことで、データを柔軟に変形することが可能になる。
-   **dplyr**はデータ操作を「文法」として表現するパッケージで、基本的なデータ処理である、選択、抽出、並び替え、集計、加工の5工程を実行する関数をそれぞれ提供する。
-   **dplyr**はtidyデータの利用を前提としており、関数内部ではデータフレームの変数名を指定した処理が中心となる。
-   **dplyr**が提供する結合関数は、変数の対応関係を考慮したリレーショナルな処理も行える。
